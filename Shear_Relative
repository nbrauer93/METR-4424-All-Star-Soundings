file = 'nexrad_3d_v4_0_20170826T000000Z.nc'
nc = Dataset(file, 'r')


radar_data = read_file(file)
zh = radar_data['Z_H']['values'][:]
radarlat = nc.variables['Latitude'][:]
radarlon = nc.variables['Longitude'][:]-360
alt = nc.variables['Altitude'][:]

radarlat2,radarlon2 = np.meshgrid(radarlat,radarlon)

track = 'Harvey_Best_Track.txt'

harvey = np.loadtxt(track, dtype = 'str', skiprows = 1)

#Lat-lon of actual hurricane location

latitude = harvey[:,4] 
longitude = harvey[:,5]
time = harvey[:,:2]
pres = harvey[:,7]


#Convert from degrees to km

def latlon_to_dist(lat_input2,lat_input1,lon_input2,lon_input1):
    distlat = (lat_input2-lat_input1)*111
    distlon = (lon_input2 - lon_input1)*111
    totaldist = np.sqrt((distlat)**2 + (distlon)**2)
    
    return(totaldist)
        
#These are the coordinates of Harvey
    
coords = np.array([latitude,longitude],dtype = 'float').T # 74x2
centerpoint = coords[41,:] #This is the centerpoint at the time of the radar image

################ Based off center, define eyewall, inner rainbands, and outer rainbands ###############

#First, take differences in lat-lon coordinates equating to 15,60, and 110 km 

sum_eyewall = 15/111  
sum_inner = 60/111
sum_outer = 110/111

#These are intervals from the centerpoint defining each annuli
eyewall_dist = np.where(coords[:,:]<=sum_eyewall+coords[:,:])[0]
inner_dist = np.where((coords[:,:]+sum_eyewall>coords[:,:])&(coords[:,:]>=sum_inner+coords[:,:]))[0]
outer_dist = np.where((coords[:,:]+sum_inner>coords[:,:])&(coords[:,:]>=sum_outer+coords[:,:]))[0]
    

#These variables 


eyewall_lat_top = np.ones((74,2))*np.nan
inner_lat_top = np.ones((74,2))*np.nan
outer_lat_top = np.ones((74,2))*np.nan
eyewall_lat_bot = np.ones((74,2))*np.nan
inner_lat_bot = np.ones((74,2))*np.nan
outer_lat_bot = np.ones((74,2))*np.nan



for i in range(coords.shape[0]):
    eyewall_lat_top[i,:] = coords[i,:]+sum_eyewall
    inner_lat_top[i,:] = coords[i,:]+sum_inner
    outer_lat_top[i,:] = coords[i,:] + sum_outer
    eyewall_lat_bot[i,:] = coords[i,:]-sum_eyewall
    inner_lat_bot[i,:] = coords[i,:]-sum_inner
    outer_lat_bot[i,:] = coords[i,:] - sum_outer


eyewall_lon_top = np.ones((74,2))*np.nan
inner_lon_top = np.ones((74,2))*np.nan
outer_lon_top = np.ones((74,2))*np.nan 
eyewall_lon_bot = np.ones((74,2))*np.nan
inner_lon_bot = np.ones((74,2))*np.nan
outer_lon_bot = np.ones((74,2))*np.nan 
    
for j in range(coords.shape[1]):
   eyewall_lon_top[:,j] = coords[:,j]+sum_eyewall
   inner_lon_top[:,j] = coords[:,j]+sum_inner
   outer_lon_top[:,j] = coords[:,j] + sum_outer   
   eyewall_lon_bot[:,j] = coords[:,j]-sum_eyewall
   inner_lon_bot[:,j] = coords[:,j]-sum_inner
   outer_lon_bot[:,j] = coords[:,j] - sum_outer    


#Now we have defined the lat-lon coordinates for each range from the center (coords); combine new coords into a single array
   

eyewall_lat_only_top = eyewall_lat_top[:,0]
inner_lat_only_top = inner_lat_top[:,0]
outer_lat_only_top = outer_lat_top[:,0]
eyewall_lon_only_top = eyewall_lon_top[:,1]
inner_lon_only_top = inner_lon_top[:,1]
outer_lon_only_top = outer_lon_top[:,1]

eyewall_lat_only_bot = eyewall_lat_bot[:,0]
inner_lat_only_bot = inner_lat_bot[:,0]
outer_lat_only_bot = outer_lat_bot[:,0]
eyewall_lon_only_bot = eyewall_lon_bot[:,1]
inner_lon_only_bot = inner_lon_bot[:,1]
outer_lon_only_bot = outer_lon_bot[:,1]

###Defining max and min points for lat and lon. All radar variables within these outer and inner ranges will be averaged over space. 

   
eyewall_annulus_max = np.array([eyewall_lat_only_top,eyewall_lon_only_top]).T
eyewall_annulus_min = np.array([eyewall_lat_only_bot,eyewall_lon_only_bot]).T
inner_annulus_max = np.array([inner_lat_only_top,inner_lon_only_top]).T
inner_annulus_min = np.array([inner_lat_only_bot,inner_lon_only_bot]).T
outer_annulus_max = np.array([outer_lat_only_top,outer_lon_only_top]).T
outer_annulus_min = np.array([outer_lat_only_bot,outer_lon_only_bot]).T


   

#Assign values of reflectivity that fall within each annulus

###Test for this case at 8/26 00Z (index 41)

###Extracts only the values that fall within the  assigned radius for each annulus
radar_eyewall_lat = np.where((eyewall_annulus_max[41,0]>=radarlat)&(eyewall_annulus_min[41,0]<=radarlat))[0]
radar_eyewall_lon = np.where((eyewall_annulus_max[41,1]>=radarlon)&(eyewall_annulus_min[41,1]<=radarlon))[0]
radar_inner_lat = np.where((inner_annulus_max[41,0]>=radarlat)&(inner_annulus_min[41,0]<=radarlat))[0]
radar_inner_lon = np.where((inner_annulus_max[41,1]>=radarlon)&(inner_annulus_min[41,1]<=radarlon))[0]
radar_outer_lat = np.where((outer_annulus_max[41,0]>=radarlat)&(outer_annulus_min[41,0]<=radarlat))[0]
radar_outer_lon = np.where((outer_annulus_max[41,1]>=radarlon)&(outer_annulus_min[41,1]<=radarlon))[0]




#Assign the indices to the radar data
zh_eyewall = zh[:,radar_eyewall_lat,radar_eyewall_lon]
zh_inner = zh[:,radar_inner_lat,radar_inner_lon]
zh_outer = zh[:,radar_outer_lat,radar_outer_lon]




#Take spatial mean of each annuli; will output a spatially-averaged vertical profile
zh_eyewall_mean = np.nanmean(zh_eyewall,axis=1)
zh_inner_mean = np.nanmean(zh_inner,axis=1)
zh_outer_mean = np.nanmean(zh_outer,axis=1)



##Set labels for altitude

alt_label = ['1','1.5','2','2.5','3','3.5','4','4.5','5','5.5','6','6.5','7','8','9','10','11','12','13','14','15','16','17','18','19','20','21','22']



plt.figure(figsize=(10,6))
plt.plot(zh_eyewall_mean,alt_label, color = 'b', linestyle = 'dashed', label = 'Eyewall')
plt.plot(zh_inner_mean,alt_label, color = 'r', label = 'Inner Rainbands')
plt.plot(zh_outer_mean,alt_label, color = 'k', label = 'Outer Rainbands')
plt.xlabel('Reflectivity Factor (dBZ)',weight = 'bold', size = 16)
plt.ylabel('Altitude (km)', weight = 'bold', size = 16)
plt.title('Reflectivity Factor Spatial Mean 8/26 00Z', weight = 'bold', size = 20)
plt.legend()
plt.show()






lon_axis_coords = np.ones(160)*np.nan
lat_axis_coords = np.ones(160)*np.nan
'''
for i in range(np.min(outer_lon_top[:,0]),np.max(outer_lon_top[:,0])):
    for j in range(np.min(outer_lat_top[:,1]),np.max(outer_lat_top[:,1])):
        
'''        




plt.figure(figsize=(18,12))
    #cornpmm, lon = shiftgrid(180., corrnpmm, lon, start=False)
    #lon, lat = np.meshgrid(np.linspace(-180, 180, 360), np.linspace(-90, 90, 180))
xlim = np.array([-100,-92]); ylim = np.array([24,31])
#xlim = np.array([-110,-85]); ylim = np.array([10,50])
    #parallels = np.arange(27.,35.,1.)
    # labels = [left,right,top,bottom]
m = Basemap(projection='cyl',lon_0=np.mean(xlim),lat_0=np.mean(ylim),llcrnrlat=ylim[0],urcrnrlat=ylim[1],llcrnrlon=xlim[0],urcrnrlon=xlim[1],resolution='l')
m.drawcoastlines(); m.drawstates(), m.drawcountries()  #m.drawparallels(parallels,labels=[True,True,True,True], size = 20) #m.fillcontinents(color='Black');m.drawparallels(np.arange(-180.,180.,30.), labels = [1,0,0,0]);m.drawmeridians(np.arange(-180,180,30),labels = [0,0,0,1])
    #xCoord,yCoord = m(lat2, lon2)  ###Add lat-lon here
cs = m.contourf(radarlon2,radarlat2,zh[4,:,:].T, cmap = zhcolor) #plot lat, lon, and North Pacific SST Anomalies
m.drawcounties()
###Plot center of Harvey from BT data on here: coord[47]
    
    
####These few lines plot the entire track of Harvey,not just a single point in time    
'''
xjunk,yjunk = m(coords[:,1],coords[:,0])
m.plot(xjunk,yjunk,'ko',markersize = 10)
plt.show()
'''
#################


'''
#x2star,y2star = m(centerpoint[1],centerpoint[0])
#m.plot(x2star,y2star,'ko',markersize=10)
x,y = m(centerpoint[0],centerpoint[1])
x2,y2 = m(centerpoint[0],centerpoint[0]+sum_inner)
c= create_circle((x,y),y2-y)
plot_circle(c)
plt.show() 
'''


#%%


ufile = 'uwnd.201708.nc'
vfile = 'vwnd.201708.nc'
heightfile = 'geopotential.nc'

uwind = Dataset(ufile, 'r')
vwind = Dataset(vfile, 'r')
z = Dataset(heightfile, 'r')

narr = {}

time = uwind.variables['time'][:]
timeUnits = uwind.variables['time'].units
tmpDates = num2date(time,timeUnits,calendar='gregorian')
narr['date'] = np.asarray([datetime(d.year,d.month,d.day) for d in tmpDates])
narr['day'] = np.asarray([d.day for d in narr['date']])
narr['month'] = np.asarray([d.month for d in narr['date']])
narr['year'] = np.asarray([d.year for d in narr['date']])
narr['hour'] = np.asarray([d.hour for d in narr['date']])

narr2 = {}

time2 = z.variables['time'][:]
timeUnits2 = z.variables['time'].units
tmpDates2 = num2date(time2,timeUnits2,calendar='gregorian')
narr2['date'] = np.asarray([datetime(d.year,d.month,d.day) for d in tmpDates2])
narr2['day'] = np.asarray([d.day for d in narr2['date']])
narr2['month'] = np.asarray([d.month for d in narr2['date']])
narr2['year'] = np.asarray([d.year for d in narr2['date']])
narr2['hour'] = np.asarray([d.hour for d in narr2['date']])


aug_index = np.where((narr['day']>=25)&(narr['month']==8))[0]
aug_index2 = np.where((narr2['day']>=25))[0]





u = uwind.variables['uwnd'][aug_index,:,:,:]
v = vwind.variables['vwnd'][aug_index,:,:,:]
height = z.variables['hgt'][aug_index2,:,:,:]
wind_lat = uwind.variables['lat'][:]
wind_lon = vwind.variables['lon'][:]



height850 = height[:,6,:,:]
height200 = height[:,24,:,:]

level = uwind.variables['level'][:]

u850 = u[:,6,:,:]
v850 = v[:,6,:,:]
u200 = u[:,24,:,:]
v200 = v[:,24,:,:]

def wind_mag (u,v):
    wind = np.sqrt((u**2)+(v**2))
    return wind

wind850 = wind_mag(u850,v850)
wind200 = wind_mag(u200,v200)


#Compute the deep-layer (850-200 mb shear)

daily850mean = np.ones((7,277,349))*np.nan
daily200mean = np.ones((7,277,349))*np.nan
u850mean = np.ones((7,277,349))*np.nan
v850mean = np.ones((7,277,349))*np.nan
u200mean = np.ones((7,277,349))*np.nan
v200mean = np.ones((7,277,349))*np.nan


for i in range(daily850mean.shape[0]):
    daily850mean[i,:,:] = np.nanmean(wind850[i:(8*i)+8,:,:], axis = 0)
    daily200mean[i,:,:] = np.nanmean(wind200[i:(8*i)+8,:,:], axis = 0)
    u850mean[i,:,:] = np.nanmean(u850[i:(8*i)+8,:,:], axis = 0)
    v850mean[i,:,:] = np.nanmean(v850[i:(8*i)+8,:,:], axis = 0)
    u200mean[i,:,:] = np.nanmean(u200[i:(8*i)+8,:,:], axis = 0)
    v200mean[i,:,:] = np.nanmean(v200[i:(8*i)+8,:,:], axis = 0)


#Now compute shear. Upper wind-low wind/height between 850 and 250 mb
    
    
shear_mag = (daily200mean-daily850mean) 


#Also need the shear direction:


ushear = (u200mean-u850mean)/(height200-height850)
vshear = (v200mean-v850mean)/(height200-height850)
 

###Designate quadrants for shear profile;

#u positive, v positive; SW-NE shear vector (DR qudrant)
#u negative, v negative; NE-SW shear vector (UL qudrant)
#u positive, v negative; NW-SE shear vector (UR quadrant)
#u negative, v positive; SE-NW shear vector (DL quadrant)

dr_index = np.where((ushear>0)&(vshear>0))[0]
ul_index = np.where((ushear<0)&(vshear<0))[0]
ur_index = np.where((ushear>0)&(vshear<0))[0]
dl_index = np.where((ushear<0)&(vshear>0))[0]


####Designate shear-relative quadrants based off best track lat-lon (coords)

ul_shear = 











###Okay cool. Now split into DL,DR,UL,UR qudrants. Will need the deep-layer shear vector here.

#Designate a center line along the center point;
